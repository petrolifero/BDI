#include <stdio.h>
#include <algorithm>
#include <cassert>
#include <stdlib.h>
#include <string>
#include <string.h>
#include <vector>
#include <iterator>
#include <sstream>
#include <iostream>

using namespace std;

void identificarComando(string &comando);

/**
 *	Seraração de Strings em vetores
 * 
 * */
void split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss;
    ss.str(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
}


std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}

/**
 *	Remoção de espaços consecutivos
 * */
bool BothAreSpaces(char lhs, char rhs) { 
	return ((lhs == rhs) && (lhs == ' ' || lhs == '\t')) 
			|| (lhs == '\t' && rhs == ' ')
			|| (lhs == ' ' && rhs == '\t'); 
}

void limpar(string &s){
	string::iterator novo_fim = unique(s.begin(), s.end(), BothAreSpaces);
	s.erase(novo_fim, s.end());   
}

// Função de interface com código em C
// obtém comando do arquivo, e passa para o manipulador do select
// PRE: arquivo está posicionado num SELECT
void select(FILE *ponteiroArquivo){
	assert(ponteiroArquivo != NULL && "Ponteiro de arquivo inválido");
	
	int rc = 0;
	char *linha = NULL;
	size_t tam = 0;
	
	rc = getdelim(&linha, &tam, ';', ponteiroArquivo);
	assert(rc != -1 && "Arquivo corrompido: falha na leitura de um SELECT\n");

	string comando(linha);
	replace( comando.begin(), comando.end(), '\n', ' ');
	
	identificarComando(comando);
	free(linha);
}

/**
 *	Função de parsing do comando passado.
 *
 *	PRE: comando é válido, string != NULL
 * */
void identificarComando(string &comando){
	
	if(comando.empty()){
		return;
	}
	
	limpar(comando);

	//Lista de cláusulas
	vector<string> clausulas(split(comando, ' '));
	
	//Estado inicial: lendo SELECT
	int estado = 0;

	vector<string> atributos;
	string relacao, where, relacaoB, condicao;

	for (string clausula : clausulas){
		switch(estado){
			case 0:
				//Comando SELECT, continua
				estado++;
				break;
			case 1:
				//ler lista de atributos
				atributos = split(clausula, ',');
				estado++;
				break;
			case 2:
				//Clausula FROM
				if(clausulas.size() < 5){
					//Caso de uma seleção sem join, possivelmente com where
					estado++;
				} else {
					// caso de uma seleção com join, possivelmente com where
					estado += 3;				
				}
				break;
			case 3:
				//seleção -join -where
				//nome da relação
				relacao = clausula;
				
				//seleção -join +where
				if(clausulas.size() > 4)
					estado++;
				else
					//fim
					estado = 99;
				break;
			case 4:
				//condição where
				//seleção -join +where
				where = clausula;
				estado = 99;
				break;
			case 5:
				//seleção +join ?where
				relacao = 
				break;
			default:
				//tudo lido
				break;
		}
	}

					relacao = clausulas[3];
					relacao.erase( remove(relacao.begin(), relacao.end(), '('), relacao.end() );
					relacaoB = clausulas[5];

					condicao = clausulas[7];
					condicao.erase( remove(condicao.begin(), condicao.end(), ')'), condicao.end() );

					//seleção +join +where
					if(clausulas.size() > 8)
						where = clausulas[9];
	//Junção
	/*if(clausulas[4] == "JOIN"){
		string relacaoA, relacaoB;
		string condicao;
		

		where = clausulas[9];

		cout << relacaoA << ", " << relacaoB << ", " << condicao << ", " << where << ".\n";
	} else {
		string relacao = clausulas[3];

		where = clausulas[5];
		cout << relacao << ", " << where << ".\n";
	}*/
}

int main(int argc, char **argv){
	FILE *arq = fopen(argv[1], "r");
	select(arq);
	/*select(arq);
	select(arq);
	select(arq);
	select(arq);*/
	fclose(arq);
}
